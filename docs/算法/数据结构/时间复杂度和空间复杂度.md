# 时间复杂度
判断一个算法所编程序运行时间的多少,并不是将程序编写出来,通过在计算机上运行所消耗的时间来度量.原因很简单,一方面,解决一个问题的算法可能有很多种,一一实现的工作量无疑是巨大的,得不偿失的;另一方面,不同计算机的软硬件环境不同,即使使用同一台计算机,不同时间段其系统环境也不相同,程序的运行时间很可能会受影响,严重时甚至会导致误判.
实际场景中,我们更喜欢用一个估值来表示算法所编程序的运行时间.也就是说,表示一个算法缩编程序运行时间的多少,用的并不是准确值,而是根据合理方法得到的预估值.
怎样预估一个算法所编程序的运行时间呢?很简单,分别计算程序中每条语句的执行次数,然后用总的执行次数简介表示程序的运行时间.
以一段简单的java语言为例,预估出此段程序的运行时间:
```java
for(int i=0;i<n;i++){ //从0到n,执行了n+1次
	a++;	//从0到n-1,执行了n次
}
```
可以看到,这段程序中仅有2行代码,其中:

- for循环从i的值为0一直逐级增至n(注意,循环退出的时候i的值为n),因此for循环语句执行了n+1次
- 循环内部仅有一条语句,a++从i的值为0就开始执行,i的值每增加1,该语句就执行一次,一直到i的值为n-1,因此,a++语句一共执行n次.

因此,整段代码中所有语句共执行了(n+1)+n次,即2n+1次.数据结构中,每条语句被执行的次数,又被称为该语句的频度.整段代码的总执行次数,即整段代码的频度.
再举一个例子:
```java
for(int i=0;i<n;i++){ //n+1
	for(int j=0;j<m;j++){ //m*(n+1)
    	num++; //n*m
    }
}
```
计算此段程序的频度为:(n+1)+n*(m+1)+n*m,简化后得2*n*m+2*n+1.值得一提的是,不同程序的运行时间,更多场景中比较的是最坏条件下程序运行的时间.以上这段程序的最坏条件下程序的运行时间是指n,m都为无限大时此段程序的运行时间.
要知道当,n,m都是无限大的时候,我们完全就可以认为n==m.在此基础上,2*n*m+2*n+1又可以简化为2*n^2+2n+1.这就是此段程序在最坏情况下的运行时间,也就是此段程序的频度.
如果比较以上2段程序的运行时间,,即比较2n+1和2*n^2+2*n+1的大小,显然当n无限大时,前者要远远小于后者;
思考一个问题,类似2n+1,2*n^2+2*n+1这样的频度,还可以在简化吗?答案是肯定的.
以2n+1为例,当n无限大时,是否在2n的基础上在做+1的操作,并无关紧要,因为2n和2n+1当n无限大时,它们的值是无限接近的,甚至与我们还可以认为,当n无限大时,是否给n乘2,也是无关紧要的,因为n是无限大,2*n也是无限大.
再以无限大的思想来简化2*n^2+2*n+1.当n无限大:

   - 首先常数1可以忽略不计
   - 对于指数级别的2*n^2来说,是否在其基础上加上2*n,并无关紧要
   - 对于是否给n^2乘2,也可以忽略.

因此,最终可以简化成n^2.
事实上,对于一个算法(或者一段程序)来说,其最简频度往往就是最深层次的循环结构中某一条语句的执行次数.例如2n+1最简为n,实际上就是a++语句执行的次数;同样2n^2+2n+1简化为n^2,实际上就是内层循环中num++语句的执行次数.
我为了避免人们随意使用a、b、c等字符来表示运行时间，需要建立统一的规范。数据结构推出大O记法；
大O记法的表示方法,格式如下:
```javascript
O(频度)
```
如下列举了常用的几种时间复杂度,以及他们之间的大小关系:
```javascript
O(1)常数阶<O(logn)对数阶<O(n)线性阶<O(n^2)平方阶<O(n^3)立方阶<O(2^n)指数阶                                                                              
```
> 注意,这里仅介绍了以最坏的情况下的频度作为时间复杂度,而在某些实际场景中,还可以用最好情况下的频度和最坏情况下的频度的平均值作为算法的时间复杂度

# 空间复杂度
和时间复杂度类似,一个算法的空间复杂度,也常用大O记法表示.
要知道每个算法所编写的程序,运行过程中都需要占用大小不等的储存空间,例如:

- 程序代码本身所占用的储存空间;
- 程序中如果需要输入输出数据,也会占用一定的储存空间;
- 程序运行过程中,可能还需要临时申请更多的储存空间.

事实上,对算法的空间复杂度影响最大的,往往是程序运行过程中所申请的临时存储空间,不同的算法所编写出的程序,其运行申请的临时储存空间通常会有较大不同,
举个例子:
```java
int n;
int a[10];
```
通过分析不难看出,这段程序在运行时所申请的临时空间,并不随n的值而变化.如果把第二行代码改为:
```java
int a[n]
```
此时,程序运行所申请的临时空间,和n值有直接的关联;
所以,如果程序所占的储存空间和输入值无关,则该程序的空间复杂度就为O(1);反之,如果有关,则需要进一步判断他们之间的关系;

- 如果随着n值的增大,程序所申请的临时空间成线性增长,则程序的空间复杂度用O(n)表示;
- 如果随着输入值n的增大,程序申请的临时空间成n^2关系增长,则程序的空间复杂度用O(n^2)表示;
- 如果随着输入值n的增大,程序申请的临时空间成n^3关系增长,则程序的空间复杂度用O(n^3)表示;
> 在多数场景中,一个好的算法往往更注重的是时间复杂度的比较,而空间复杂度只要在一个合理的范围就可以了

