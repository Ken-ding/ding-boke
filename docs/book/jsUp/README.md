# 第一部分
## 第一章 作用域是什么
### 1.1 编译原理
#### 传统编译流程
- 分词/词法分析
- 解析/语法分析(抽象语法树)
- 代码生成
#### js编译流程
编译发生在代码执行前的几微秒(甚至更短),javascript引擎用尽各种办法(比如JIT,可以延迟编译甚至实施重新编译),来保证性能更佳
### 1.2 理解作用域
#### 1.2.1 演员表表
- 引擎:从头到尾负责整个javascript程序的编译及执行过程
- 编译器:负责语法分析及代码生成等脏活累活
- 作用域:负责收集并维护由所有声明的标识符(变量)组成的一系列查询,并实施一套规则,确定当前执行代码对这些标识符的访问权限
#### 1.2.2 对话
> 编译器处理过程 var a =2;
- var a;编译器检查当前作用域，有a，忽略声明，没有a，当前作用域声明a
- a=2;引擎检查当前作用域集合，有a,使用，没有，继续查找，直到找到a并赋值，否则，抛异常
#### 1.2.3 编译器有话说
变量出现在左侧，进行LHS查询，出现在右侧进行RHS查询
- 左查询(LHS):试图找到变量的容器本身,从而可以对其赋值
- 右查询(RHS):取到它的源值
### 1.3 作用域嵌套
引擎从当前执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。
## 第二章 词法作用域
> ps:词法作用域是由你在写代码时将变量和快作用域写在哪里来决定的,因此当词法分析器处理代码时会保持作用域不变(大部分情况是这样的)
```javascript
function foo(a){
    var b=a*2;
    function bar(c){
        console.log(a,b,c)
    }
    bar(b*3);
}
foo(2);//2,4,12
```
- 包含着整个全局作用域，其中只有一个标识符：foo。
- 包含着foo所创建的作用域，其中有三个标识符：a，bar，b。
- 包含着bar所创建的作用域，其中只有一个标识符：c。
### 2.2 欺骗词法
#### 2.2.1 eaval
javascript中的eaval()函数可以接受一个字符串为参数,并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。
>如下代码：
```js
function foo(str,a){
    eval(str);
    console.log(a,b);
}
var b=2;
foo("var b=3;",1);//1,3
```
- eval()所执行的代码包含一个或多个声明，就会对eval()所处的词法作用域进行修改。
- setTimeout()和setInterval()的第一个可以是字符串,字符串的内容可以被解释为一段动态生成的函数代码
- 这些过时且并不被提倡.不要使用他们:它所带来的好处是无法抵消性能上的损失
#### 2.2.2 with
>ps:不推荐使用

**用法**
通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身

```js
var obj={
    a:1,
    b:2,
    c:3
};
//单调乏味的重复"obj"
obj.a=2;
obj.b=3;
obj.c=4;
//简单的快捷方式
wit(obj){
    a=3;
    b=4;
    c=5;
}
```
**副作用**

```js
function foo(obj){
    with(obj){
        a=2;
    }
    var o1={
        a:3
    }
    var o2={
        b:3
    }
    foo(o1);
    console.log(o1.a);//2

    foo(o2);
    console.log(o2.a);//undefined
    console.log(a);//2---不好，a被泄露到全局作用域上了
}
```
- with可以将一个没有或多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。
- with可以将一个对象处理为词法作用域，但是这块内部正常的var声明并不会被限制在这个的作用域中，而是被添加到with所处的函数作用域中
#### 性能
eval()和with()
- js引擎会在编译阶段进行很多性能优化,很多都是基于静态分析的,并预先确定所有的变量和函数位置,才能在执行过程中快速找到标识符
- 无法在词法分析阶段明确知道接受的代码,这些优化对这两种方法无效,导致代码运行更慢

### 小结
- 词法作用域意味着作用域是由书写代码时函数声明的位置决定
- 编译的词法分析阶段基本能够知道全部标识符在哪里以及如何声明的
- eval()和with()可以欺骗词法作用域,引擎无法在编译阶段对作用域查找进行优化,不要使用他们

## 第三章 函数作用域和块作用域


